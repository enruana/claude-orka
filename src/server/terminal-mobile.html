<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Orka Terminal</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/css/xterm.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: #1e1e2e;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    #app {
      display: flex;
      flex-direction: column;
      height: 100%;
      width: 100%;
    }

    #terminal-container {
      flex: 1;
      overflow: hidden;
      position: relative;
    }

    #terminal-container .xterm {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }

    #terminal-container .xterm-viewport {
      overflow-y: auto !important;
    }

    /* Drag and drop visual feedback */
    #terminal-container.drag-over {
      outline: 2px dashed #89b4fa;
      outline-offset: -2px;
      background: rgba(137, 180, 250, 0.1);
    }

    #terminal-container.drag-over::after {
      content: 'Drop file to paste path';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(30, 30, 46, 0.9);
      color: #89b4fa;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      pointer-events: none;
      z-index: 100;
    }

    /* Virtual Keyboard */
    #virtual-keyboard {
      display: none;
      background: linear-gradient(180deg, #181825 0%, #11111b 100%);
      border-top: 1px solid #313244;
      padding: 12px 16px;
      padding-bottom: calc(12px + env(safe-area-inset-bottom, 0px));
    }

    .keyboard-grid {
      display: grid;
      grid-template-columns: auto auto minmax(100px, auto) auto auto;
      grid-template-rows: auto auto;
      gap: 10px 14px;
      align-items: center;
      justify-content: center;
      padding: 4px 0;
    }

    /* Row 1 positioning */
    .keyboard-grid > button:nth-child(1) { grid-area: 1 / 1; } /* TAB */
    .keyboard-grid > button:nth-child(2) { grid-area: 1 / 2; } /* ESC */
    .keyboard-grid > button:nth-child(3) { grid-area: 1 / 3; justify-self: center; } /* ‚ñ≤ */
    .keyboard-grid > button:nth-child(4) { grid-area: 1 / 4; } /* MIC */
    .keyboard-grid > .quick-actions-container { grid-area: 1 / 5; position: relative; } /* Quick Actions */

    /* Row 2 positioning */
    .keyboard-grid > button:nth-child(6) { grid-area: 2 / 1; } /* PASTE */
    .keyboard-grid > span:nth-child(7) { grid-area: 2 / 2; } /* empty */
    .keyboard-grid > .arrow-row { grid-area: 2 / 3; justify-self: center; } /* arrows */
    .keyboard-grid > span:nth-child(9) { grid-area: 2 / 4; } /* empty */
    .keyboard-grid > button:nth-child(10) { grid-area: 2 / 5; } /* ENTER */

    .quick-actions-container {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .arrow-row {
      display: flex;
      gap: 6px;
      justify-content: center;
      align-items: center;
    }

    .key-btn {
      background: linear-gradient(135deg, #3b3d54 0%, #313244 100%);
      color: #cdd6f4;
      border: none;
      border-radius: 12px;
      padding: 10px 16px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      touch-action: manipulation;
      min-width: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      -webkit-tap-highlight-color: transparent;
      outline: none;
      transition: all 0.15s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    .key-btn:focus {
      outline: none;
    }

    .key-btn:active {
      background: linear-gradient(135deg, #45475a 0%, #3b3d54 100%);
      transform: scale(0.95);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    /* Arrow keys - slightly smaller and more compact */
    .arrow-row .key-btn {
      min-width: 36px;
      padding: 10px 12px;
      font-size: 14px;
    }

    /* Special keys styling */
    .key-btn[data-key="tab"],
    .key-btn[data-key="esc"] {
      background: linear-gradient(135deg, #45475a 0%, #3b3d54 100%);
      color: #bac2de;
      font-size: 11px;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 44px;
    }

    .key-btn[data-key="paste"] {
      background: linear-gradient(135deg, #cba6f7 0%, #b4befe 100%);
      color: #1e1e2e;
      box-shadow: 0 2px 6px rgba(203, 166, 247, 0.3);
      min-width: auto;
      padding: 10px 14px;
      font-size: 11px;
    }

    .key-btn[data-key="paste"]:active {
      background: linear-gradient(135deg, #b4befe 0%, #89b4fa 100%);
    }

    .key-btn.enter {
      background: linear-gradient(135deg, #89b4fa 0%, #74c7ec 100%);
      color: #1e1e2e;
      box-shadow: 0 2px 6px rgba(137, 180, 250, 0.3);
      font-size: 16px;
    }

    .key-btn.enter:active {
      background: linear-gradient(135deg, #74c7ec 0%, #94e2d5 100%);
    }

    /* Microphone button */
    .key-btn.mic {
      background: linear-gradient(135deg, #94e2d5 0%, #74c7ec 100%);
      border: none;
      color: #1e1e2e;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 44px;
      height: 44px;
      padding: 0;
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(148, 226, 213, 0.3);
    }

    .key-btn.mic:active {
      background: linear-gradient(135deg, #74c7ec 0%, #89b4fa 100%);
      transform: scale(0.95);
    }

    .key-btn.mic svg {
      display: block;
      stroke: #1e1e2e;
    }

    .key-btn.mic.recording {
      background: linear-gradient(135deg, #f38ba8 0%, #eba0ac 100%);
      box-shadow: 0 2px 12px rgba(243, 139, 168, 0.5);
      animation: pulse 1s ease-in-out infinite;
    }

    .key-btn.mic.recording svg {
      stroke: #1e1e2e;
    }

    .key-btn.mic.transcribing {
      background: linear-gradient(135deg, #f9e2af 0%, #fab387 100%);
      box-shadow: 0 2px 12px rgba(249, 226, 175, 0.5);
    }

    .key-btn.mic.transcribing svg {
      stroke: #1e1e2e;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.05); }
    }

    /* Quick Actions button */
    .key-btn.quick-actions {
      background: linear-gradient(135deg, #f9e2af 0%, #fab387 100%);
      border: none;
      color: #1e1e2e;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 44px;
      height: 44px;
      padding: 0;
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(249, 226, 175, 0.3);
      position: relative;
    }

    .key-btn.quick-actions:active {
      background: linear-gradient(135deg, #fab387 0%, #f38ba8 100%);
      transform: scale(0.95);
    }

    .key-btn.quick-actions svg {
      display: block;
      stroke: #1e1e2e;
    }

    .key-btn.quick-actions.active {
      background: linear-gradient(135deg, #fab387 0%, #f38ba8 100%);
      box-shadow: 0 2px 12px rgba(249, 226, 175, 0.5);
    }

    /* Quick Actions Popup */
    #quick-actions-popup {
      display: none;
      position: absolute;
      bottom: calc(100% + 12px);
      right: 0;
      background: #1e1e2e;
      border: 1px solid #313244;
      border-radius: 16px;
      padding: 8px;
      min-width: 180px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      z-index: 100;
      animation: popupSlideUp 0.2s ease;
    }

    #quick-actions-popup.visible {
      display: block;
    }

    @keyframes popupSlideUp {
      from {
        opacity: 0;
        transform: translateY(8px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .quick-action-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 14px;
      border-radius: 10px;
      color: #cdd6f4;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
      border: none;
      background: none;
      width: 100%;
      text-align: left;
    }

    .quick-action-item:active {
      background: #313244;
      transform: scale(0.98);
    }

    .quick-action-item .action-icon {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .quick-action-item .action-icon.keyboard {
      background: linear-gradient(135deg, #89b4fa 0%, #74c7ec 100%);
    }

    .quick-action-item .action-icon.clear {
      background: linear-gradient(135deg, #f38ba8 0%, #eba0ac 100%);
    }

    .quick-action-item .action-icon.scroll-top {
      background: linear-gradient(135deg, #a6e3a1 0%, #94e2d5 100%);
    }

    .quick-action-item .action-icon.scroll-bottom {
      background: linear-gradient(135deg, #cba6f7 0%, #b4befe 100%);
    }

    .quick-action-item .action-icon svg {
      stroke: #1e1e2e;
    }

    .quick-action-item .action-text {
      flex: 1;
    }

    .quick-actions-backdrop {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 99;
    }

    .quick-actions-backdrop.visible {
      display: block;
    }

    /* Status bar */
    #status-bar {
      background: #11111b;
      color: #6c7086;
      padding: 4px 8px;
      font-size: 11px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }

    #status-bar .connected {
      color: #a6e3a1;
    }

    #status-bar .disconnected {
      color: #f38ba8;
    }

    #status-bar.retry {
      background: #f38ba8;
      color: #1e1e2e;
    }

    /* Show keyboard on mobile */
    @media (max-width: 768px), (pointer: coarse) {
      #virtual-keyboard {
        display: flex;
        flex-direction: column;
      }
    }

    /* Loading/Connection overlay */
    #connection-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(30, 30, 46, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      transition: opacity 0.3s ease;
    }

    #connection-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #connection-overlay.connected {
      opacity: 0;
      pointer-events: none;
    }

    .connection-spinner {
      width: 48px;
      height: 48px;
      border: 4px solid #313244;
      border-top-color: #89b4fa;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    .connection-text {
      color: #cdd6f4;
      font-size: 16px;
      font-weight: 500;
      text-align: center;
      margin-bottom: 8px;
    }

    .connection-subtext {
      color: #6c7086;
      font-size: 13px;
      text-align: center;
    }

    .connection-retry-btn {
      margin-top: 20px;
      background: #89b4fa;
      color: #1e1e2e;
      border: none;
      border-radius: 12px;
      padding: 12px 24px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: none;
    }

    .connection-retry-btn.visible {
      display: block;
    }

    .connection-retry-btn:active {
      background: #74c7ec;
      transform: scale(0.98);
    }

    /* Error state */
    #connection-overlay.error .connection-spinner {
      border-color: #f38ba8;
      border-top-color: #f38ba8;
      animation: none;
    }

    #connection-overlay.error .connection-text {
      color: #f38ba8;
    }

    /* Legacy loading for backwards compat */
    #loading {
      display: none;
    }

    /* Input Modal */
    #input-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(17, 17, 27, 0.95);
      z-index: 1000;
      align-items: flex-end;
      justify-content: center;
      padding: 0;
    }

    #input-modal.visible {
      display: flex;
    }

    .modal-content {
      background: #1e1e2e;
      border-top: 1px solid #313244;
      border-radius: 16px 16px 0 0;
      width: 100%;
      max-width: 100%;
      padding: 16px;
      padding-bottom: calc(16px + env(safe-area-inset-bottom, 0px));
      box-shadow: 0 -4px 24px rgba(0, 0, 0, 0.4);
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid #313244;
    }

    .modal-title {
      color: #cdd6f4;
      font-size: 15px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .modal-title-icon {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-title-icon svg {
      display: block;
    }

    .modal-close {
      background: #313244;
      border: none;
      color: #9399b2;
      font-size: 18px;
      cursor: pointer;
      padding: 6px 10px;
      border-radius: 8px;
      line-height: 1;
    }

    .modal-close:active {
      background: #45475a;
    }

    .modal-input-container {
      margin-bottom: 12px;
    }

    .modal-textarea {
      width: 100%;
      min-height: 100px;
      max-height: 200px;
      background: #11111b;
      color: #cdd6f4;
      border: 2px solid #313244;
      border-radius: 12px;
      padding: 14px;
      font-size: 16px;
      font-family: inherit;
      line-height: 1.5;
      resize: none;
      outline: none;
      transition: border-color 0.2s ease;
    }

    .modal-textarea:focus {
      border-color: #89b4fa;
    }

    .modal-textarea::placeholder {
      color: #6c7086;
    }

    .modal-hint {
      font-size: 12px;
      color: #6c7086;
      margin-top: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .modal-hint-icon {
      font-size: 14px;
    }

    .modal-actions {
      display: flex;
      gap: 10px;
    }

    .modal-btn {
      flex: 1;
      padding: 14px 20px;
      border: none;
      border-radius: 12px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .modal-btn.cancel {
      background: #313244;
      color: #cdd6f4;
    }

    .modal-btn.cancel:active {
      background: #45475a;
    }

    .modal-btn.send {
      background: #89b4fa;
      color: #1e1e2e;
    }

    .modal-btn.send:active {
      background: #74c7ec;
    }

    .modal-btn.send:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Transcription status (for recording feedback) */
    .transcription-status {
      background: #11111b;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
      text-align: center;
    }

    .transcription-status.recording {
      background: linear-gradient(135deg, #45475a 0%, #313244 100%);
      border: 2px solid #f38ba8;
    }

    .transcription-status.processing {
      background: linear-gradient(135deg, #45475a 0%, #313244 100%);
      border: 2px solid #f9e2af;
    }

    .status-icon {
      font-size: 32px;
      margin-bottom: 8px;
      display: block;
    }

    .status-text {
      color: #cdd6f4;
      font-size: 14px;
      font-weight: 500;
    }

    .status-subtext {
      color: #6c7086;
      font-size: 12px;
      margin-top: 4px;
    }

    /* Spinner animation */
    .spinner {
      width: 24px;
      height: 24px;
      border: 3px solid #313244;
      border-top-color: #89b4fa;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin: 0 auto 8px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Recording indicator overlay */
    #recording-indicator {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #f38ba8 0%, #eba0ac 100%);
      color: #1e1e2e;
      padding: 20px 32px;
      border-radius: 16px;
      font-size: 15px;
      font-weight: 600;
      z-index: 999;
      text-align: center;
      box-shadow: 0 8px 32px rgba(243, 139, 168, 0.3);
    }

    #recording-indicator.visible {
      display: block;
      animation: pulse-scale 1.5s ease-in-out infinite;
    }

    @keyframes pulse-scale {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.02); }
    }

    #recording-indicator .rec-dot {
      display: inline-block;
      width: 12px;
      height: 12px;
      background: #1e1e2e;
      border-radius: 50%;
      margin-right: 10px;
      animation: blink 1s ease-in-out infinite;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    /* Copy toast indicator */
    #copy-toast {
      display: none;
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #a6e3a1 0%, #94e2d5 100%);
      color: #1e1e2e;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 600;
      z-index: 999;
      box-shadow: 0 4px 16px rgba(166, 227, 161, 0.3);
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    #copy-toast.visible {
      display: block;
      opacity: 1;
    }

    #copy-toast.fade-out {
      opacity: 0;
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Connection overlay -->
    <div id="connection-overlay">
      <div class="connection-spinner"></div>
      <div class="connection-text">Connecting to terminal...</div>
      <div class="connection-subtext">Please wait</div>
      <button class="connection-retry-btn" id="connection-retry">Tap to retry</button>
    </div>

    <div id="terminal-container">
      <div id="loading">Connecting...</div>
    </div>

    <div id="virtual-keyboard">
      <div class="keyboard-grid">
        <!-- Row 1: TAB, ESC, ‚ñ≤, üé§, ‚ö° -->
        <button class="key-btn" data-key="tab">TAB</button>
        <button class="key-btn" data-key="esc">ESC</button>
        <button class="key-btn" data-key="up">‚ñ≤</button>
        <button class="key-btn mic" data-key="mic" id="mic-btn">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/>
            <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
            <line x1="12" x2="12" y1="19" y2="22"/>
          </svg>
        </button>
        <div class="quick-actions-container">
          <button class="key-btn quick-actions" id="quick-actions-btn" data-key="quick-actions">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
            </svg>
          </button>
          <div id="quick-actions-popup">
            <button class="quick-action-item" data-action="keyboard">
              <span class="action-icon keyboard">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <rect x="2" y="4" width="20" height="16" rx="2"/>
                  <path d="M6 8h.001M10 8h.001M14 8h.001M18 8h.001M8 12h.001M12 12h.001M16 12h.001M6 16h12"/>
                </svg>
              </span>
              <span class="action-text">Open Keyboard</span>
            </button>
            <button class="quick-action-item" data-action="scroll-top">
              <span class="action-icon scroll-top">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M12 19V5M5 12l7-7 7 7"/>
                </svg>
              </span>
              <span class="action-text">Scroll to Top</span>
            </button>
            <button class="quick-action-item" data-action="scroll-bottom">
              <span class="action-icon scroll-bottom">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M12 5v14M5 12l7 7 7-7"/>
                </svg>
              </span>
              <span class="action-text">Scroll to Bottom</span>
            </button>
            <button class="quick-action-item" data-action="clear">
              <span class="action-icon clear">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
                </svg>
              </span>
              <span class="action-text">Clear Terminal</span>
            </button>
          </div>
        </div>

        <!-- Row 2: PASTE, (empty), ‚óÄ‚ñº‚ñ∂, (empty), ENTER -->
        <button class="key-btn" data-key="paste">PASTE</button>
        <span></span>
        <div class="arrow-row">
          <button class="key-btn" data-key="left">‚óÄ</button>
          <button class="key-btn" data-key="down">‚ñº</button>
          <button class="key-btn" data-key="right">‚ñ∂</button>
        </div>
        <span></span>
        <button class="key-btn enter" data-key="enter">‚èé</button>
      </div>
    </div>

    <!-- Quick Actions Backdrop -->
    <div class="quick-actions-backdrop" id="quick-actions-backdrop"></div>

    <div id="status-bar">
      <span id="status">Connecting...</span>
      <span id="dimensions"></span>
    </div>
  </div>

  <!-- Recording Indicator -->
  <div id="recording-indicator">
    <span class="rec-dot"></span>
    Recording... Release to stop
  </div>

  <!-- Copy Toast -->
  <div id="copy-toast">Copied!</div>

  <!-- Input Modal (for voice/text input) -->
  <div id="input-modal">
    <div class="modal-content">
      <div class="modal-header">
        <span class="modal-title">
          <span class="modal-title-icon" id="modal-icon">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/>
              <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
              <line x1="12" x2="12" y1="19" y2="22"/>
            </svg>
          </span>
          <span id="modal-title-text">Voice Input</span>
        </span>
        <button class="modal-close" id="modal-close">‚úï</button>
      </div>
      <div id="modal-body">
        <div class="modal-input-container">
          <textarea
            class="modal-textarea"
            id="modal-textarea"
            placeholder="Type or use voice dictation..."
          ></textarea>
          <div class="modal-hint">
            <span class="modal-hint-icon">üí°</span>
            <span id="modal-hint-text">Use keyboard microphone for voice dictation</span>
          </div>
        </div>
      </div>
      <div class="modal-actions">
        <button class="modal-btn cancel" id="modal-cancel">Cancel</button>
        <button class="modal-btn send" id="modal-send">Send</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/lib/xterm.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0.10.0/lib/addon-fit.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-webgl@0.18.0/lib/addon-webgl.min.js"></script>
  <script>
    // ttyd protocol commands
    const Command = {
      // Client -> Server
      INPUT: '0',
      RESIZE_TERMINAL: '1',
      PAUSE: '2',
      RESUME: '3',
      JSON_DATA: '{',
      // Server -> Client
      OUTPUT: '0',
      SET_WINDOW_TITLE: '1',
      SET_PREFERENCES: '2'
    };

    // Key sequences
    const KeySequences = {
      'esc': '\x1b',
      'tab': '\t',
      'enter': '\r',
      'up': '\x1b[A',
      'down': '\x1b[B',
      'right': '\x1b[C',
      'left': '\x1b[D',
      'paste': '\x16' // Ctrl+V
    };

    // Voice Recorder class
    class VoiceRecorder {
      constructor(options = {}) {
        this.onTranscribe = options.onTranscribe || (() => {});
        this.onStart = options.onStart || (() => {});
        this.onStop = options.onStop || (() => {});
        this.onError = options.onError || ((err) => console.error(err));
        this.onPermissionNeeded = options.onPermissionNeeded || (() => {});

        this.mediaRecorder = null;
        this.chunks = [];
        this.stream = null;
        this.isRecording = false;
        this.permissionGranted = false;
      }

      async checkPermission() {
        try {
          // Check if permissions API is available
          if (navigator.permissions && navigator.permissions.query) {
            const result = await navigator.permissions.query({ name: 'microphone' });
            console.log('Microphone permission state:', result.state);
            return result.state;
          }
          // Fallback: assume we need to request
          return 'prompt';
        } catch (err) {
          console.log('Permissions API not available:', err);
          return 'prompt';
        }
      }

      async requestPermission() {
        try {
          // Request microphone access
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          // Permission granted, stop the test stream
          stream.getTracks().forEach(track => track.stop());
          this.permissionGranted = true;
          console.log('Microphone permission granted');
          return true;
        } catch (err) {
          console.error('Microphone permission denied:', err);
          this.permissionGranted = false;

          // Determine error type
          if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
            this.onError('Microphone access denied. Please allow microphone access in your browser settings.');
          } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
            this.onError('No microphone found. Please connect a microphone.');
          } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
            this.onError('Microphone is in use by another application.');
          } else if (err.name === 'OverconstrainedError') {
            this.onError('Microphone constraints cannot be satisfied.');
          } else if (err.name === 'SecurityError') {
            this.onError('Microphone access blocked. Page must be served over HTTPS.');
          } else {
            this.onError(`Microphone error: ${err.message || err.name}`);
          }
          return false;
        }
      }

      async start() {
        try {
          // Check if mediaDevices API is available
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            // Check if we're on HTTPS or localhost
            const isSecure = window.location.protocol === 'https:' ||
                            window.location.hostname === 'localhost' ||
                            window.location.hostname === '127.0.0.1';

            if (!isSecure) {
              this.onError('Microphone requires HTTPS. Access this page via localhost or enable HTTPS.');
            } else {
              this.onError('Microphone not supported in this browser.');
            }
            return;
          }

          // Check current permission state
          const permState = await this.checkPermission();

          if (permState === 'denied') {
            this.onError('Microphone access denied. Please enable it in browser settings and reload the page.');
            return;
          }

          // Request permission if needed
          if (!this.permissionGranted && permState !== 'granted') {
            this.onPermissionNeeded();
          }

          // Get microphone access
          this.stream = await navigator.mediaDevices.getUserMedia({
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              sampleRate: 16000
            }
          });

          this.permissionGranted = true;

          // Detect supported format (important for iOS)
          const mimeType = this.getSupportedMimeType();
          console.log('Using audio format:', mimeType);

          this.mediaRecorder = new MediaRecorder(this.stream, { mimeType });
          this.chunks = [];

          this.mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
              this.chunks.push(e.data);
            }
          };

          this.mediaRecorder.onstop = async () => {
            this.isRecording = false;
            this.onStop();

            if (this.chunks.length === 0) {
              this.onError('No audio recorded');
              return;
            }

            const blob = new Blob(this.chunks, { type: mimeType });
            console.log('Audio blob size:', blob.size);

            // Clean up stream
            this.stream.getTracks().forEach(track => track.stop());

            // Transcribe
            try {
              const text = await this.transcribe(blob, mimeType);
              this.onTranscribe(text);
            } catch (err) {
              this.onError(err.message);
            }
          };

          this.mediaRecorder.start();
          this.isRecording = true;
          this.onStart();
          console.log('Recording started');

        } catch (err) {
          console.error('Failed to start recording:', err);

          // Clean up any partial stream
          if (this.stream) {
            this.stream.getTracks().forEach(track => track.stop());
            this.stream = null;
          }

          // Determine error type and show appropriate message
          if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
            this.onError('Microphone access denied. Please allow microphone access and try again.');
          } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
            this.onError('No microphone found. Please connect a microphone.');
          } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
            this.onError('Microphone is busy. Close other apps using it and try again.');
          } else if (err.name === 'SecurityError') {
            this.onError('Microphone blocked. Use HTTPS or localhost.');
          } else {
            this.onError(`Recording failed: ${err.message || 'Unknown error'}`);
          }
        }
      }

      stop() {
        if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
          this.mediaRecorder.stop();
          console.log('Recording stopped');
        }
      }

      cancel() {
        if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
          this.mediaRecorder.stop();
        }
        if (this.stream) {
          this.stream.getTracks().forEach(track => track.stop());
        }
        this.chunks = [];
        this.isRecording = false;
      }

      getSupportedMimeType() {
        // Order of preference
        const types = [
          'audio/webm;codecs=opus',
          'audio/webm',
          'audio/mp4',
          'audio/ogg;codecs=opus',
          'audio/wav'
        ];

        for (const type of types) {
          if (MediaRecorder.isTypeSupported(type)) {
            return type;
          }
        }

        return 'audio/webm'; // Fallback
      }

      async transcribe(blob, mimeType) {
        // Get the orka server URL (same origin, different port)
        const orkaPort = new URLSearchParams(window.location.search).get('orkaPort') || '3456';
        const orkaHost = window.location.hostname;
        const transcribeUrl = `http://${orkaHost}:${orkaPort}/api/transcribe`;

        console.log('Sending audio to:', transcribeUrl);

        const response = await fetch(transcribeUrl, {
          method: 'POST',
          headers: {
            'Content-Type': mimeType
          },
          body: blob
        });

        if (!response.ok) {
          const error = await response.json().catch(() => ({ error: 'Transcription failed' }));
          throw new Error(error.message || error.error || 'Transcription failed');
        }

        const result = await response.json();
        console.log('Transcription result:', result);

        if (!result.text || result.text.trim() === '') {
          throw new Error('No speech detected');
        }

        return result.text.trim();
      }
    }

    class OrkaTerminal {
      constructor() {
        this.term = null;
        this.fitAddon = null;
        this.socket = null;
        this.textEncoder = new TextEncoder();
        this.textDecoder = new TextDecoder();
        this.ctrlPressed = false;
        this.altPressed = false;
        this.authToken = '';
        this.retryTimeout = null;
        this.voiceRecorder = null;
        this.transcribedText = '';
        this.copyToastTimeout = null;

        this.init();
      }

      showCopyToast(charCount) {
        const toast = document.getElementById('copy-toast');
        if (!toast) return;

        // Clear any existing timeout
        if (this.copyToastTimeout) {
          clearTimeout(this.copyToastTimeout);
        }

        toast.textContent = `Copied ${charCount} character${charCount !== 1 ? 's' : ''}`;
        toast.classList.remove('fade-out');
        toast.classList.add('visible');

        // Start fade out after 1.5s
        this.copyToastTimeout = setTimeout(() => {
          toast.classList.add('fade-out');
          // Remove after transition
          setTimeout(() => {
            toast.classList.remove('visible', 'fade-out');
          }, 200);
        }, 1500);
      }

      async init() {
        // Get ttyd port from URL path: /terminal/:port or /terminal/:port/
        const pathParts = window.location.pathname.split('/').filter(p => p.trim());
        const port = pathParts[pathParts.length - 1];

        if (!port || isNaN(parseInt(port))) {
          this.showError('Invalid terminal port');
          return;
        }

        this.ttydPort = port;
        this.ttydHost = window.location.hostname;
        this.retryCount = 0;
        this.maxRetries = 5;

        // First, get auth token from ttyd
        try {
          const tokenResponse = await fetch(`http://${this.ttydHost}:${this.ttydPort}/token`);
          if (tokenResponse.ok) {
            const tokenData = await tokenResponse.json();
            this.authToken = tokenData.token || '';
          }
        } catch (e) {
          console.log('No auth token required or token endpoint not available');
        }

        this.createTerminal();
        this.connectWebSocket();
        this.setupKeyboard();
        this.setupResize();
        this.setupSwipeScroll();
        this.setupStatusBar();
        this.setupVoiceRecorder();
        this.setupQuickActions();
      }

      setupVoiceRecorder() {
        const micBtn = document.getElementById('mic-btn');
        const recordingIndicator = document.getElementById('recording-indicator');

        // Check if we can use native recording (HTTPS or localhost)
        const canUseNativeRecording = navigator.mediaDevices &&
          navigator.mediaDevices.getUserMedia &&
          (window.location.protocol === 'https:' ||
           window.location.hostname === 'localhost' ||
           window.location.hostname === '127.0.0.1');

        if (canUseNativeRecording) {
          this.setupNativeRecording(micBtn, recordingIndicator);
        } else {
          // Use keyboard fallback (opens modal with textarea for native keyboard dictation)
          this.setupKeyboardFallback(micBtn);
        }

        this.setupModalHandlers();
      }

      setupNativeRecording(micBtn, recordingIndicator) {
        this.voiceRecorder = new VoiceRecorder({
          onStart: () => {
            micBtn.classList.add('recording');
            recordingIndicator.innerHTML = '<span class="rec-dot"></span> Recording... Release to stop';
            recordingIndicator.classList.add('visible');
          },
          onStop: () => {
            micBtn.classList.remove('recording');
            micBtn.classList.add('transcribing');
            recordingIndicator.classList.remove('visible');
            this.showProcessingState();
          },
          onTranscribe: (text) => {
            micBtn.classList.remove('transcribing');
            this.showTextInModal(text);
          },
          onError: (error) => {
            micBtn.classList.remove('recording', 'transcribing');
            recordingIndicator.classList.remove('visible');
            this.showErrorInModal(error);
          },
          onPermissionNeeded: () => {
            recordingIndicator.innerHTML = '<span class="rec-dot"></span> Allow microphone access...';
            recordingIndicator.classList.add('visible');
          }
        });

        // Hold to record (touch)
        let recordingStarted = false;

        micBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          recordingStarted = true;
          this.voiceRecorder.start();
        }, { passive: false });

        micBtn.addEventListener('touchend', (e) => {
          e.preventDefault();
          if (recordingStarted) {
            recordingStarted = false;
            this.voiceRecorder.stop();
          }
        });

        micBtn.addEventListener('touchcancel', (e) => {
          e.preventDefault();
          if (recordingStarted) {
            recordingStarted = false;
            this.voiceRecorder.cancel();
            micBtn.classList.remove('recording');
            recordingIndicator.classList.remove('visible');
          }
        });

        // Mouse support for desktop
        micBtn.addEventListener('mousedown', (e) => {
          e.preventDefault();
          recordingStarted = true;
          this.voiceRecorder.start();
        });

        micBtn.addEventListener('mouseup', (e) => {
          e.preventDefault();
          if (recordingStarted) {
            recordingStarted = false;
            this.voiceRecorder.stop();
          }
        });

        micBtn.addEventListener('mouseleave', () => {
          if (recordingStarted) {
            recordingStarted = false;
            this.voiceRecorder.cancel();
            micBtn.classList.remove('recording');
            recordingIndicator.classList.remove('visible');
          }
        });
      }

      setupKeyboardFallback(micBtn) {
        // Single tap opens modal with textarea for native keyboard dictation
        micBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.openInputModal('voice');
        });
      }

      setupModalHandlers() {
        const modal = document.getElementById('input-modal');
        const modalClose = document.getElementById('modal-close');
        const modalCancel = document.getElementById('modal-cancel');
        const modalSend = document.getElementById('modal-send');
        const modalTextarea = document.getElementById('modal-textarea');

        const closeModal = () => {
          modal.classList.remove('visible');
          modalTextarea.value = '';
        };

        modalClose.addEventListener('click', closeModal);
        modalCancel.addEventListener('click', closeModal);

        modalSend.addEventListener('click', () => {
          const text = modalTextarea.value.trim();
          if (text) {
            this.sendInput(text);
            closeModal();
          }
        });

        // Close on backdrop click
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            closeModal();
          }
        });

        // Enable/disable send button based on input
        modalTextarea.addEventListener('input', () => {
          modalSend.disabled = !modalTextarea.value.trim();
        });
      }

      openInputModal(type) {
        const modal = document.getElementById('input-modal');
        const modalIcon = document.getElementById('modal-icon');
        const modalTitle = document.getElementById('modal-title-text');
        const modalHint = document.getElementById('modal-hint-text');
        const modalTextarea = document.getElementById('modal-textarea');
        const modalSend = document.getElementById('modal-send');

        if (type === 'voice') {
          modalIcon.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/></svg>';
          modalTitle.textContent = 'Voice Input';
          modalHint.textContent = 'Tap the microphone on your keyboard to dictate';
          modalTextarea.placeholder = 'Type or use voice dictation...';
        } else {
          modalIcon.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="8" height="4" x="8" y="2" rx="1" ry="1"/><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/></svg>';
          modalTitle.textContent = 'Paste Text';
          modalHint.textContent = 'Paste text from clipboard';
          modalTextarea.placeholder = 'Paste your text here...';
        }

        modalTextarea.value = '';
        modalSend.disabled = true;
        modal.classList.add('visible');

        // Focus textarea after modal is visible
        setTimeout(() => modalTextarea.focus(), 100);
      }

      showProcessingState() {
        const modal = document.getElementById('input-modal');
        const modalBody = document.getElementById('modal-body');
        const modalSend = document.getElementById('modal-send');

        modalBody.innerHTML = `
          <div class="transcription-status processing">
            <div class="spinner"></div>
            <span class="status-text">Transcribing audio...</span>
            <span class="status-subtext">Please wait</span>
          </div>
        `;
        modalSend.disabled = true;
        modal.classList.add('visible');
      }

      showTextInModal(text) {
        const modal = document.getElementById('input-modal');
        const modalBody = document.getElementById('modal-body');
        const modalTextarea = document.getElementById('modal-textarea');
        const modalSend = document.getElementById('modal-send');

        // Restore textarea
        modalBody.innerHTML = `
          <div class="modal-input-container">
            <textarea
              class="modal-textarea"
              id="modal-textarea"
              placeholder="Type or use voice dictation..."
            ></textarea>
            <div class="modal-hint">
              <span class="modal-hint-icon">‚úì</span>
              <span id="modal-hint-text">Transcription complete - edit if needed</span>
            </div>
          </div>
        `;

        const newTextarea = document.getElementById('modal-textarea');
        newTextarea.value = text;
        modalSend.disabled = false;
        newTextarea.focus();
        newTextarea.setSelectionRange(text.length, text.length);

        // Re-add input listener
        newTextarea.addEventListener('input', () => {
          modalSend.disabled = !newTextarea.value.trim();
        });
      }

      showErrorInModal(error) {
        const modal = document.getElementById('input-modal');
        const modalBody = document.getElementById('modal-body');
        const modalSend = document.getElementById('modal-send');

        modalBody.innerHTML = `
          <div class="transcription-status" style="border: 2px solid #f38ba8;">
            <span class="status-icon">‚ö†Ô∏è</span>
            <span class="status-text" style="color: #f38ba8;">${error}</span>
            <span class="status-subtext">Try using the keyboard microphone instead</span>
          </div>
          <div class="modal-input-container" style="margin-top: 12px;">
            <textarea
              class="modal-textarea"
              id="modal-textarea"
              placeholder="Type or use voice dictation..."
            ></textarea>
          </div>
        `;

        const newTextarea = document.getElementById('modal-textarea');
        modalSend.disabled = true;
        newTextarea.focus();

        newTextarea.addEventListener('input', () => {
          modalSend.disabled = !newTextarea.value.trim();
        });

        modal.classList.add('visible');
      }

      createTerminal() {
        const container = document.getElementById('terminal-container');

        // Check if desktop mode (embedded in web UI)
        const isDesktopMode = new URLSearchParams(window.location.search).get('desktop') === '1';

        // Use smaller font on mobile (unless in desktop mode)
        const isMobile = !isDesktopMode && (
          window.matchMedia('(max-width: 768px)').matches ||
          window.matchMedia('(pointer: coarse)').matches
        );

        // Hide virtual keyboard in desktop mode
        if (isDesktopMode) {
          document.getElementById('virtual-keyboard').style.display = 'none';
        }

        // Font sizes: mobile=6, desktop embedded=11, standalone=14
        const fontSize = isMobile ? 6 : (isDesktopMode ? 11 : 14);

        this.term = new Terminal({
          cursorBlink: true,
          cursorStyle: 'block',
          fontSize: fontSize,
          fontFamily: 'Menlo, Monaco, "Courier New", monospace',
          theme: {
            background: '#1e1e2e',
            foreground: '#cdd6f4',
            cursor: '#f5e0dc',
            cursorAccent: '#1e1e2e',
            selectionBackground: '#585b70',
            black: '#45475a',
            red: '#f38ba8',
            green: '#a6e3a1',
            yellow: '#f9e2af',
            blue: '#89b4fa',
            magenta: '#f5c2e7',
            cyan: '#94e2d5',
            white: '#bac2de',
            brightBlack: '#585b70',
            brightRed: '#f38ba8',
            brightGreen: '#a6e3a1',
            brightYellow: '#f9e2af',
            brightBlue: '#89b4fa',
            brightMagenta: '#f5c2e7',
            brightCyan: '#94e2d5',
            brightWhite: '#a6adc8'
          },
          allowProposedApi: true,
          scrollback: 5000
        });

        this.fitAddon = new FitAddon.FitAddon();
        this.term.loadAddon(this.fitAddon);

        // Try WebGL renderer
        try {
          const webglAddon = new WebglAddon.WebglAddon();
          this.term.loadAddon(webglAddon);
        } catch (e) {
          console.log('WebGL not available, using canvas renderer');
        }

        this.term.open(container);

        // Disable browser context menu on terminal
        container.addEventListener('contextmenu', (e) => {
          e.preventDefault();
        });

        // Prevent keyboard from auto-opening on touch devices
        // xterm.js uses a hidden textarea to capture keyboard input
        // We intercept focus and prevent it unless explicitly requested
        const isTouchDevice = window.matchMedia('(pointer: coarse)').matches ||
                              'ontouchstart' in window ||
                              navigator.maxTouchPoints > 0;

        if (isTouchDevice && !isDesktopMode && this.term.textarea) {
          // Allow keyboard to be opened explicitly via Quick Actions
          this.keyboardAllowed = false;

          this.term.textarea.addEventListener('focus', (e) => {
            if (!this.keyboardAllowed) {
              // Blur immediately to prevent keyboard from opening
              setTimeout(() => {
                if (this.term.textarea && !this.keyboardAllowed) {
                  this.term.textarea.blur();
                }
              }, 0);
            }
          });
        }

        // Clear accidental selections when terminal gains focus
        // This prevents small selections from overwriting the clipboard when switching terminals
        this.term.textarea.addEventListener('focus', () => {
          // Small delay to let any click-based selection complete
          setTimeout(() => {
            const selection = this.term.getSelection();
            // If selection is very small (likely accidental click), clear it
            if (selection && selection.length < 3) {
              this.term.clearSelection();
            }
          }, 50);
        });

        // Also clear tiny selections on mouseup/touchend to prevent accidental copies
        container.addEventListener('mouseup', () => {
          setTimeout(() => {
            const selection = this.term.getSelection();
            if (selection && selection.length < 3) {
              this.term.clearSelection();
            }
          }, 10);
        });

        container.addEventListener('touchend', () => {
          setTimeout(() => {
            const selection = this.term.getSelection();
            if (selection && selection.length < 3) {
              this.term.clearSelection();
            }
          }, 10);
        }, { passive: true });

        // Fit after layout is ready
        requestAnimationFrame(() => {
          this.fitAddon.fit();
          // Fit again after a short delay to ensure correct size
          setTimeout(() => {
            this.fitAddon.fit();
            this.sendResize();
          }, 100);
        });

        document.getElementById('loading').classList.add('hidden');

        // Handle drag and drop of files
        this.setupDragAndDrop();

        // Listen for postMessage from parent (for cross-tab drag and drop)
        window.addEventListener('message', (event) => {
          if (event.data && event.data.type === 'terminal-input' && event.data.text) {
            this.sendInput(event.data.text);
            this.term.focus();
            console.log('Received input via postMessage:', event.data.text);
          }
        });

        // Handle paste - intercept at the earliest point to prevent xterm's built-in handling
        const handlePaste = (event) => {
          const clipboardData = event.clipboardData || window.clipboardData;
          if (clipboardData) {
            const text = clipboardData.getData('text') || clipboardData.getData('text/plain');
            if (text && text.length > 0) {
              // IMPORTANT: Prevent default and stop propagation to block xterm's handling
              event.preventDefault();
              event.stopPropagation();
              event.stopImmediatePropagation();

              this.sendInput(text);
              console.log('Pasted:', text.length, 'characters');
              return true;
            }
          }
          return false;
        };

        // Capture paste at document level with capture phase (runs before xterm)
        document.addEventListener('paste', handlePaste, { capture: true });

        // Handle Cmd+V / Ctrl+V - block xterm's default and use clipboard API
        this.term.attachCustomKeyEventHandler((event) => {
          // Check for Cmd+V (Mac) or Ctrl+V (Windows/Linux)
          if ((event.metaKey || event.ctrlKey) && event.key === 'v' && event.type === 'keydown') {
            console.log('Cmd+V detected');

            // Prevent xterm from handling this - we'll handle paste via the paste event
            // or via clipboard API
            event.preventDefault();

            // Try clipboard API as primary method
            if (navigator.clipboard && navigator.clipboard.readText) {
              navigator.clipboard.readText()
                .then(text => {
                  if (text && text.length > 0) {
                    this.sendInput(text);
                    console.log('Pasted via Clipboard API:', text.length, 'characters');
                  }
                })
                .catch(err => {
                  console.log('Clipboard API failed, relying on paste event:', err.message);
                  // The paste event should still fire and handle it
                });
            }

            // Return false to prevent xterm from processing this key
            return false;
          }

          // Check for Cmd+C / Ctrl+C for copy
          if ((event.metaKey || event.ctrlKey) && event.key === 'c' && event.type === 'keydown') {
            const selection = this.term.getSelection();
            // Only copy if selection is meaningful (3+ characters)
            // This prevents accidental tiny selections from overwriting clipboard
            if (selection && selection.length >= 3) {
              navigator.clipboard.writeText(selection).then(() => {
                console.log('Copied:', selection.length, 'characters');
                this.showCopyToast(selection.length);
              }).catch(err => {
                console.error('Failed to copy:', err);
              });
              return false;
            }
            // If no meaningful selection, send Ctrl+C to terminal (interrupt)
            return true;
          }

          // Allow all other keys
          return true;
        });

        // Handle terminal input
        this.term.onData((data) => {
          this.sendInput(data);
        });
      }

      connectWebSocket() {
        // Cancel any pending retry timeout
        if (this.retryTimeout) {
          clearTimeout(this.retryTimeout);
          this.retryTimeout = null;
        }

        // Clean up any existing socket before creating new one
        if (this.socket) {
          this.socket.onclose = null;
          this.socket.onerror = null;
          this.socket.onmessage = null;
          this.socket.onopen = null;
          if (this.socket.readyState === WebSocket.OPEN ||
              this.socket.readyState === WebSocket.CONNECTING) {
            this.socket.close();
          }
          this.socket = null;
        }

        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${this.ttydHost}:${this.ttydPort}/ws`;

        const retryMsg = this.retryCount > 0 ? ` (retry ${this.retryCount})` : '';
        this.updateStatus('Connecting...' + retryMsg, false);

        try {
          this.socket = new WebSocket(wsUrl, ['tty']);
        } catch (e) {
          console.error('WebSocket creation failed:', e);
          this.scheduleRetry();
          return;
        }
        this.socket.binaryType = 'arraybuffer';

        this.socket.onopen = () => {
          this.retryCount = 0;
          this.term.clear();
          this.fitAddon.fit();

          // Wait for layout to stabilize before sending auth
          // Mobile devices need more time for proper dimension calculation
          const sendAuthWhenReady = (attempts = 0) => {
            if (this.socket?.readyState !== WebSocket.OPEN) {
              return;
            }

            // Try to fit the terminal
            this.fitAddon.fit();

            // Check if we have valid dimensions
            if (!this.hasValidDimensions() && attempts < 10) {
              // Retry after delay (up to 10 attempts = ~2 seconds)
              console.log(`Waiting for valid dimensions (attempt ${attempts + 1})...`);
              setTimeout(() => sendAuthWhenReady(attempts + 1), 200);
              return;
            }

            const { cols, rows } = this.term;

            // Use fallback dimensions if still invalid after all attempts
            const finalCols = cols > 0 ? cols : 80;
            const finalRows = rows > 0 ? rows : 24;

            const authData = JSON.stringify({
              AuthToken: this.authToken,
              columns: finalCols,
              rows: finalRows
            });

            console.log(`Sending auth with dimensions: ${finalCols}x${finalRows}`);
            this.socket.send(Command.JSON_DATA + authData);
            this.sendResize();
            this.updateStatus('Connected', true);
          };

          // Start with initial delay for mobile layout
          setTimeout(() => sendAuthWhenReady(0), 150);
        };

        this.socket.onmessage = (event) => {
          const data = event.data;

          if (typeof data === 'string') {
            const cmd = data[0];
            const payload = data.slice(1);

            if (cmd === Command.OUTPUT) {
              this.term.write(payload);
            } else if (cmd === Command.SET_WINDOW_TITLE) {
              document.title = payload || 'Orka Terminal';
            }
          } else if (data instanceof ArrayBuffer) {
            const view = new Uint8Array(data);
            const cmd = String.fromCharCode(view[0]);
            const payload = view.slice(1);

            if (cmd === Command.OUTPUT) {
              this.term.write(payload);
            } else {
              this.term.write(view);
            }
          }
        };

        this.socket.onerror = (e) => {
          console.error('WebSocket error:', e);
          this.updateStatus('Connection error', false);
        };

        this.socket.onclose = (e) => {
          console.log('WebSocket closed:', e.code, e.reason);
          this.scheduleRetry();
        };
      }

      scheduleRetry() {
        if (this.retryCount >= this.maxRetries) {
          this.updateStatus('Failed to connect - tap to retry', false);
          return;
        }

        this.retryCount++;
        const delay = Math.min(1000 * this.retryCount, 5000);

        this.updateStatus(`Reconnecting in ${delay/1000}s...`, false);

        this.retryTimeout = setTimeout(() => {
          this.retryTimeout = null;
          this.connectWebSocket();
        }, delay);
      }

      sendInput(data) {
        if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
          console.log('Socket not ready, state:', this.socket?.readyState);
          return;
        }

        // Apply modifiers
        if (this.ctrlPressed && data.length === 1) {
          const char = data.toLowerCase();
          const code = char.charCodeAt(0) - 96;
          if (code >= 1 && code <= 26) {
            data = String.fromCharCode(code);
          }
          this.toggleModifier('ctrl', false);
        }

        if (this.altPressed && data.length === 1) {
          data = '\x1b' + data;
          this.toggleModifier('alt', false);
        }

        // Send INPUT command
        const dataBytes = this.textEncoder.encode(data);
        const payload = new Uint8Array(dataBytes.length + 1);
        payload[0] = Command.INPUT.charCodeAt(0);
        payload.set(dataBytes, 1);
        this.socket.send(payload);
        console.log('Sent input:', data.substring(0, 50));
      }

      sendKey(key) {
        if (key === 'mic') {
          // Handled by voice recorder
          return;
        }

        if (key === 'paste') {
          // Read from clipboard and paste
          this.pasteFromClipboard();
          return;
        }

        const sequence = KeySequences[key];
        if (sequence) {
          this.sendInput(sequence);
        }
      }

      async pasteFromClipboard(showPromptOnFailure = true) {
        console.log('Paste requested');

        // Method 1: Try Clipboard API
        if (navigator.clipboard && navigator.clipboard.readText) {
          try {
            this.term.focus();
            const text = await navigator.clipboard.readText();
            if (text && text.length > 0) {
              this.sendInput(text);
              console.log('Pasted via Clipboard API:', text.length, 'characters');
              return;
            }
          } catch (err) {
            console.log('Clipboard API failed:', err.message);
          }
        }

        // Method 2: Try using a hidden textarea with execCommand
        try {
          const textarea = document.createElement('textarea');
          textarea.style.position = 'fixed';
          textarea.style.left = '-9999px';
          textarea.style.top = '0';
          document.body.appendChild(textarea);
          textarea.focus();

          // Try to paste into the textarea
          const pasted = document.execCommand('paste');
          if (pasted && textarea.value) {
            this.sendInput(textarea.value);
            console.log('Pasted via execCommand:', textarea.value.length, 'characters');
            document.body.removeChild(textarea);
            this.term.focus();
            return;
          }
          document.body.removeChild(textarea);
        } catch (err) {
          console.log('execCommand paste failed:', err.message);
        }

        // Fallback: Show manual paste prompt
        if (showPromptOnFailure) {
          console.log('All paste methods failed, showing prompt');
          this.showPastePrompt();
        }
      }

      showPastePrompt() {
        this.openInputModal('paste');
      }

      setupDragAndDrop() {
        const terminalContainer = document.getElementById('terminal-container');

        // Prevent default drag behaviors
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
          terminalContainer.addEventListener(eventName, (e) => {
            e.preventDefault();
            e.stopPropagation();
          });
        });

        // Visual feedback on drag
        ['dragenter', 'dragover'].forEach(eventName => {
          terminalContainer.addEventListener(eventName, () => {
            terminalContainer.classList.add('drag-over');
          });
        });

        ['dragleave', 'drop'].forEach(eventName => {
          terminalContainer.addEventListener(eventName, () => {
            terminalContainer.classList.remove('drag-over');
          });
        });

        // Handle drop
        terminalContainer.addEventListener('drop', (e) => {
          const dataTransfer = e.dataTransfer;

          // Check for custom data from our FileTree (internal drag)
          const internalPath = dataTransfer.getData('text/x-orka-path');
          if (internalPath) {
            // Quote the path if it contains spaces
            const quotedPath = internalPath.includes(' ') ? `"${internalPath}"` : internalPath;
            this.sendInput(quotedPath);
            this.term.focus();
            console.log('Dropped internal path:', internalPath);
            return;
          }

          // Check for plain text (could be a path from another source)
          const textData = dataTransfer.getData('text/plain');
          if (textData && textData.trim()) {
            // Check if it looks like a path
            if (textData.startsWith('/') || textData.startsWith('~') || textData.match(/^[a-zA-Z]:\\/)) {
              const quotedPath = textData.includes(' ') ? `"${textData}"` : textData;
              this.sendInput(quotedPath);
              this.term.focus();
              console.log('Dropped text path:', textData);
              return;
            }
          }

          // Handle external file drops
          if (dataTransfer.files && dataTransfer.files.length > 0) {
            const files = Array.from(dataTransfer.files);
            const paths = files.map(file => {
              // Web browsers only give us the filename, not the full path
              // But we can still provide the name for reference
              const name = file.name;
              return name.includes(' ') ? `"${name}"` : name;
            });

            // Join multiple files with space
            const pathsStr = paths.join(' ');
            this.sendInput(pathsStr);
            this.term.focus();

            // Show hint that full paths aren't available in web
            if (files.length === 1) {
              console.log('Dropped file (name only, full path not available in web):', files[0].name);
            } else {
              console.log('Dropped', files.length, 'files (names only)');
            }
            return;
          }

          // Check for items (for directories, etc.)
          if (dataTransfer.items && dataTransfer.items.length > 0) {
            for (const item of dataTransfer.items) {
              if (item.kind === 'string') {
                item.getAsString((str) => {
                  if (str && str.trim()) {
                    const quotedStr = str.includes(' ') ? `"${str}"` : str;
                    this.sendInput(quotedStr);
                    this.term.focus();
                  }
                });
                return;
              }
            }
          }
        });
      }

      toggleModifier(modifier, state) {
        if (modifier === 'ctrl') {
          this.ctrlPressed = state !== undefined ? state : !this.ctrlPressed;
          const btn = document.getElementById('ctrl-btn');
          if (btn) btn.classList.toggle('active', this.ctrlPressed);
        } else if (modifier === 'alt') {
          this.altPressed = state !== undefined ? state : !this.altPressed;
          const btn = document.getElementById('alt-btn');
          if (btn) btn.classList.toggle('active', this.altPressed);
        }
      }

      setupKeyboard() {
        const keyboard = document.getElementById('virtual-keyboard');

        const handleKey = (e) => {
          e.preventDefault();
          e.stopPropagation();

          const btn = e.target.closest('.key-btn');
          if (!btn) return;

          const key = btn.dataset.key;

          // Skip mic and quick-actions buttons - handled separately
          if (key === 'mic' || key === 'quick-actions') return;

          this.sendKey(key);

          if (document.activeElement && document.activeElement !== document.body) {
            document.activeElement.blur();
          }
        };

        keyboard.addEventListener('pointerup', handleKey);

        keyboard.addEventListener('touchstart', (e) => {
          // Don't prevent default for mic, quick-actions, or popup items
          const target = e.target;
          if (target.closest('.key-btn.mic') ||
              target.closest('.key-btn.quick-actions') ||
              target.closest('#quick-actions-popup') ||
              target.closest('.quick-action-item')) {
            return;
          }
          e.preventDefault();
        }, { passive: false });

        keyboard.addEventListener('focus', (e) => {
          if (!e.target.closest('.key-btn.mic') && !e.target.closest('.quick-actions-container')) {
            e.target.blur();
          }
        }, true);
      }

      setupResize() {
        // Throttled resize handler to prevent dimension spam
        let resizeTimeout = null;
        let lastResizeTime = 0;
        const RESIZE_THROTTLE_MS = 150;

        const throttledResize = () => {
          const now = Date.now();

          // Clear any pending resize
          if (resizeTimeout) {
            clearTimeout(resizeTimeout);
          }

          // If enough time has passed, resize immediately
          if (now - lastResizeTime >= RESIZE_THROTTLE_MS) {
            this.fitAddon.fit();
            this.sendResize();
            lastResizeTime = now;
          } else {
            // Otherwise, schedule a resize for later
            resizeTimeout = setTimeout(() => {
              this.fitAddon.fit();
              this.sendResize();
              lastResizeTime = Date.now();
            }, RESIZE_THROTTLE_MS);
          }
        };

        const resizeObserver = new ResizeObserver(() => {
          throttledResize();
        });

        resizeObserver.observe(document.getElementById('terminal-container'));

        window.addEventListener('resize', () => {
          throttledResize();
        });

        // Handle orientation change specifically (mobile)
        window.addEventListener('orientationchange', () => {
          // Longer delay for orientation change since layout needs to settle
          setTimeout(() => {
            this.fitAddon.fit();
            this.sendResize();
          }, 300);
        });
      }

      setupSwipeScroll() {
        const container = document.getElementById('terminal-container');

        let touchStartY = 0;
        let touchStartX = 0;
        let touchStartTime = 0;
        // Track touch position for sending scroll to correct tmux pane
        let lastTouchX = 0;
        let lastTouchY = 0;
        let isSwiping = false;
        let lastScrollTime = 0;

        // Minimum distance to consider it a swipe (pixels)
        const SWIPE_THRESHOLD = 30;
        // Minimum velocity to trigger scroll (pixels/ms)
        const VELOCITY_THRESHOLD = 0.3;
        // Throttle scroll events (ms)
        const SCROLL_THROTTLE = 50;

        container.addEventListener('touchstart', (e) => {
          if (e.touches.length === 1) {
            touchStartY = e.touches[0].clientY;
            touchStartX = e.touches[0].clientX;
            lastTouchX = touchStartX;
            lastTouchY = touchStartY;
            touchStartTime = Date.now();
            isSwiping = false;
          }
        }, { passive: true });

        container.addEventListener('touchmove', (e) => {
          if (e.touches.length !== 1) return;

          const touchY = e.touches[0].clientY;
          const touchX = e.touches[0].clientX;
          const deltaY = touchStartY - touchY;
          const deltaX = Math.abs(touchStartX - touchX);

          // Track current touch position
          lastTouchX = touchX;
          lastTouchY = touchY;

          // Only consider vertical swipes (ignore horizontal)
          if (Math.abs(deltaY) > deltaX && Math.abs(deltaY) > SWIPE_THRESHOLD) {
            isSwiping = true;

            // Throttle scroll events
            const now = Date.now();
            if (now - lastScrollTime > SCROLL_THROTTLE) {
              lastScrollTime = now;

              // Send scroll: positive deltaY = swipe up = scroll up (show older content)
              const scrollLines = Math.ceil(Math.abs(deltaY) / 30);
              // Pass touch position so scroll goes to correct tmux pane
              this.sendMouseScroll(deltaY > 0 ? 'up' : 'down', scrollLines, touchX, touchY);

              // Update start position for continuous scrolling
              touchStartY = touchY;
            }

            // Prevent default to stop page scrolling
            e.preventDefault();
          }
        }, { passive: false });

        container.addEventListener('touchend', (e) => {
          if (!isSwiping) return;

          const touchEndTime = Date.now();
          const duration = touchEndTime - touchStartTime;

          // Calculate velocity for momentum scrolling
          if (duration > 0 && duration < 300) {
            const velocity = Math.abs(touchStartY - (e.changedTouches[0]?.clientY || touchStartY)) / duration;

            if (velocity > VELOCITY_THRESHOLD) {
              // Add extra scroll lines for momentum
              const extraLines = Math.ceil(velocity * 5);
              const direction = touchStartY > (e.changedTouches[0]?.clientY || touchStartY) ? 'up' : 'down';
              // Use last known touch position for correct tmux pane targeting
              this.sendMouseScroll(direction, extraLines, lastTouchX, lastTouchY);
            }
          }

          isSwiping = false;
        }, { passive: true });

        // Handle mouse wheel scroll (for desktop) - target correct tmux pane
        container.addEventListener('wheel', (e) => {
          // Use mouse position for correct tmux pane targeting
          const direction = e.deltaY > 0 ? 'down' : 'up';
          const lines = Math.max(1, Math.ceil(Math.abs(e.deltaY) / 50));
          this.sendMouseScroll(direction, lines, e.clientX, e.clientY);

          // Prevent page scroll
          e.preventDefault();
        }, { passive: false });
      }

      sendMouseScroll(direction, lines = 1, clientX = null, clientY = null) {
        if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
          return;
        }

        // Validate dimensions before sending scroll events
        if (!this.hasValidDimensions()) {
          console.warn('Skipping scroll: invalid dimensions');
          return;
        }

        const { cols, rows } = this.term;
        let col, row;

        // If touch position is provided, convert to terminal coordinates
        if (clientX !== null && clientY !== null) {
          const container = document.getElementById('terminal-container');
          const rect = container.getBoundingClientRect();

          // Calculate relative position within terminal
          const relX = clientX - rect.left;
          const relY = clientY - rect.top;

          // Convert pixel position to terminal cell coordinates
          // Terminal cell size = container size / cols (or rows)
          const cellWidth = rect.width / cols;
          const cellHeight = rect.height / rows;

          col = Math.max(1, Math.min(cols, Math.floor(relX / cellWidth) + 1));
          row = Math.max(1, Math.min(rows, Math.floor(relY / cellHeight) + 1));
        } else {
          // Fallback to center of terminal
          col = Math.floor(cols / 2);
          row = Math.floor(rows / 2);
        }

        // SGR mouse encoding for scroll wheel
        // Button 64 = scroll up, Button 65 = scroll down
        const button = direction === 'up' ? 64 : 65;

        // Send multiple scroll events for faster scrolling
        for (let i = 0; i < lines; i++) {
          // SGR format: \x1b[<button;col;rowM
          const scrollSequence = `\x1b[<${button};${col};${row}M`;
          this.sendInput(scrollSequence);
        }

        console.log(`Scroll ${direction} x${lines} at col:${col} row:${row}`);
      }

      // Validate terminal dimensions are valid before sending
      hasValidDimensions() {
        if (!this.term) return false;
        const { cols, rows } = this.term;
        return cols > 0 && rows > 0 && !isNaN(cols) && !isNaN(rows);
      }

      sendResize() {
        if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
          return;
        }

        // Validate dimensions before sending
        if (!this.hasValidDimensions()) {
          console.warn('Skipping resize: invalid dimensions');
          return;
        }

        const { cols, rows } = this.term;
        const msg = Command.RESIZE_TERMINAL + JSON.stringify({ columns: cols, rows: rows });
        this.socket.send(msg);

        document.getElementById('dimensions').textContent = `${cols}x${rows}`;
      }

      updateStatus(text, connected) {
        const status = document.getElementById('status');
        const statusBar = document.getElementById('status-bar');
        status.textContent = text;
        status.className = connected ? 'connected' : 'disconnected';

        const needsRetry = text.includes('tap to retry') || text.includes('Failed');
        statusBar.classList.toggle('retry', needsRetry);

        // Update connection overlay
        this.updateConnectionOverlay(text, connected, needsRetry);
      }

      updateConnectionOverlay(text, connected, needsRetry) {
        const overlay = document.getElementById('connection-overlay');
        const overlayText = overlay.querySelector('.connection-text');
        const overlaySubtext = overlay.querySelector('.connection-subtext');
        const retryBtn = document.getElementById('connection-retry');

        if (connected) {
          overlay.classList.add('connected');
          overlay.classList.remove('error');
          retryBtn.classList.remove('visible');
        } else {
          overlay.classList.remove('connected');

          if (needsRetry) {
            overlay.classList.add('error');
            overlayText.textContent = 'Connection lost';
            overlaySubtext.textContent = 'Unable to connect to terminal';
            retryBtn.classList.add('visible');
          } else if (text.includes('Reconnecting')) {
            overlay.classList.remove('error');
            overlayText.textContent = text;
            overlaySubtext.textContent = 'Attempting to reconnect...';
            retryBtn.classList.remove('visible');
          } else {
            overlay.classList.remove('error');
            overlayText.textContent = text;
            overlaySubtext.textContent = 'Please wait';
            retryBtn.classList.remove('visible');
          }
        }
      }

      setupStatusBar() {
        const statusBar = document.getElementById('status-bar');
        statusBar.addEventListener('click', () => {
          if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
            this.retryCount = 0;
            this.connectWebSocket();
          }
        });

        // Setup retry button in overlay
        const retryBtn = document.getElementById('connection-retry');
        retryBtn.addEventListener('click', () => {
          this.retryCount = 0;
          this.connectWebSocket();
        });
      }

      setupQuickActions() {
        const quickActionsBtn = document.getElementById('quick-actions-btn');
        const quickActionsPopup = document.getElementById('quick-actions-popup');
        const backdrop = document.getElementById('quick-actions-backdrop');

        // Toggle popup
        const togglePopup = (show) => {
          if (show) {
            quickActionsPopup.classList.add('visible');
            backdrop.classList.add('visible');
            quickActionsBtn.classList.add('active');
          } else {
            quickActionsPopup.classList.remove('visible');
            backdrop.classList.remove('visible');
            quickActionsBtn.classList.remove('active');
          }
        };

        // Toggle on button click
        quickActionsBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const isVisible = quickActionsPopup.classList.contains('visible');
          togglePopup(!isVisible);
        });

        // Close on backdrop click
        backdrop.addEventListener('click', () => {
          togglePopup(false);
        });

        // Handle action items
        quickActionsPopup.querySelectorAll('.quick-action-item').forEach(item => {
          item.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const action = item.dataset.action;
            this.executeQuickAction(action);
            togglePopup(false);
          });
        });
      }

      executeQuickAction(action) {
        switch (action) {
          case 'keyboard':
            this.openNativeKeyboard();
            break;
          case 'scroll-top':
            // Send Ctrl+Home or tmux scroll to top
            this.sendMouseScroll('up', 100);
            break;
          case 'scroll-bottom':
            // Send Ctrl+End or tmux scroll to bottom
            this.sendMouseScroll('down', 100);
            break;
          case 'clear':
            // Send Ctrl+L to clear terminal
            this.sendInput('\x0c');
            break;
        }
      }

      openNativeKeyboard() {
        // Allow keyboard focus temporarily
        this.keyboardAllowed = true;

        // Focus the terminal's internal textarea to open keyboard
        if (this.term.textarea) {
          this.term.textarea.focus();

          // Track when keyboard closes to re-enable protection
          const handleBlur = () => {
            this.keyboardAllowed = false;
            this.term.textarea.removeEventListener('blur', handleBlur);
          };
          this.term.textarea.addEventListener('blur', handleBlur);
        }
      }

      showError(message) {
        document.getElementById('loading').textContent = message;
        this.updateStatus(message, false);
      }
    }

    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      new OrkaTerminal();
    });
  </script>
</body>
</html>
